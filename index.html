<!doctype html>
<html lang="pt" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gerador de Convites PDF</title><!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script><!-- Google Fonts - Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&amp;display=swap" rel="stylesheet"><!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script><!-- PDF-LIB -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script><!-- Fontkit -->
  <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script><!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      box-sizing: border-box;
      font-family: 'Poppins', sans-serif;
    }
    
    * {
      box-sizing: border-box;
    }
    
    .toast {
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .draggable {
      cursor: move;
      user-select: none;
      touch-action: none;
    }
    
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #6366f1;
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      z-index: 20;
    }
    
    .resize-handle.bottom-right {
      bottom: -6px;
      right: -6px;
    }
    
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    
    #pdfCanvas {
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="/_sdk/element_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full bg-gray-50">
  <div id="app" class="h-full"></div>
  <script>
    // ============================================
    // CONFIGURA√á√ÉO SUPABASE
    // ============================================
    const SUPABASE_URL = 'https://okevdjxksctbkxtonllq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9rZXZkanhrc2N0Ymt4dG9ubGxxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkzNDE2OTgsImV4cCI6MjA4NDkxNzY5OH0.g8XGFbcTeR0NosiQqjMbbshDF1Xx9hHUWWPxHJe6hAc';
    
    const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    // ============================================
    // VARI√ÅVEIS GLOBAIS
    // ============================================
    let currentView = 'home';
    let currentToken = null;
    let isAdminAuthenticated = false;
    let selectedEventId = null;
    let tempPdfBytes = null;
    let tempFontBytes = null;
    let tempFontName = null;
    let canvasScale = 1;
    let pdfPageDimensions = { width: 0, height: 0 };
    let draggedElement = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let currentRenderTask = null;
    let realtimeChannel = null;
    let isResizing = false;
    let resizeStartSize = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;
    
    // Estado dos eventos e convites
    let events = [];
    let invites = [];
    let currentEvent = null;
    let qrCodes = [];
    let tempQrFiles = [];
    
    // PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    // ============================================
    // SISTEMA DE TOASTS
    // ============================================
    function showToast(message, type = 'success') {
      const toastContainer = document.getElementById('toast-container') || createToastContainer();
      
      const toast = document.createElement('div');
      toast.className = `toast px-6 py-4 rounded-lg shadow-lg text-white ${
        type === 'success' ? 'bg-green-500' : 'bg-red-500'
      }`;
      toast.textContent = message;
      
      toastContainer.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    function createToastContainer() {
      const container = document.createElement('div');
      container.id = 'toast-container';
      container.className = 'fixed top-4 right-4 z-50 flex flex-col gap-2';
      document.body.appendChild(container);
      return container;
    }
    
    // ============================================
    // GERA√á√ÉO DE TOKEN SEGURO
    // ============================================
    function generateSecureToken() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let token = '';
      const tokenLength = 32;
      
      const randomValues = new Uint8Array(tokenLength);
      crypto.getRandomValues(randomValues);
      
      for (let i = 0; i < tokenLength; i++) {
        token += chars[randomValues[i] % chars.length];
      }
      
      return token;
    }
    
    function validateToken(token) {
      if (!token || typeof token !== 'string') return false;
      
      // Remove espa√ßos em branco
      token = token.trim();
      
      // Aceita qualquer token alfanum√©rico com 4 ou mais caracteres
      if (/^[A-Za-z0-9]{4,}$/.test(token)) return true;
      
      return false;
    }
    
    // ============================================
    // NAVEGA√á√ÉO
    // ============================================
    function navigate(view, data = {}) {
      currentView = view;
      
      if (view === 'client' && data.token) {
        currentToken = data.token;
        history.pushState({}, '', `?token=${data.token}`);
      } else if (view === 'home') {
        currentToken = null;
        history.pushState({}, '', window.location.pathname);
      }
      
      render();
    }
    
    // ============================================
    // AUTENTICA√á√ÉO SUPABASE
    // ============================================
    let authStateReady = false;
    let authStatePromise = null;
    
    // Promise que resolve quando o estado inicial da autentica√ß√£o est√° pronto
    function waitForAuthReady() {
      if (authStateReady) {
        return Promise.resolve();
      }
      if (!authStatePromise) {
        authStatePromise = new Promise((resolve) => {
          const unsubscribe = sb.auth.onAuthStateChange((event, session) => {
            if (event === 'INITIAL_SESSION') {
              authStateReady = true;
              isAdminAuthenticated = !!session;
              unsubscribe.data.subscription.unsubscribe();
              resolve();
            }
          });
        });
      }
      return authStatePromise;
    }
    
    // Configurar listener permanente para mudan√ßas de autentica√ß√£o
    function setupAuthListener() {
      sb.auth.onAuthStateChange((event, session) => {
        // Atualizar estado global
        const wasAuthenticated = isAdminAuthenticated;
        isAdminAuthenticated = !!session;
        
        // Reagir a mudan√ßas de estado
        if (event === 'SIGNED_IN') {
          // Usu√°rio acabou de fazer login
          if (!wasAuthenticated) {
            loadEvents().then(() => {
              navigate('admin');
            });
          }
        } else if (event === 'SIGNED_OUT') {
          // Usu√°rio fez logout
          if (wasAuthenticated) {
            navigate('home');
          }
        } else if (event === 'TOKEN_REFRESHED') {
          // Token foi renovado, manter usu√°rio autenticado
        } else if (event === 'USER_UPDATED') {
          // Informa√ß√µes do usu√°rio foram atualizadas
        }
      });
    }
    
    async function login(email, password) {
      try {
        const { data, error } = await sb.auth.signInWithPassword({
          email,
          password
        });
        
        if (error) {
          showToast('Erro ao fazer login: ' + error.message, 'error');
          return false;
        }
        
        return true;
      } catch (error) {
        console.error('Erro ao fazer login:', error);
        showToast('Erro ao fazer login', 'error');
        return false;
      }
    }
    
    async function logout() {
      try {
        if (realtimeChannel) {
          await sb.removeChannel(realtimeChannel);
          realtimeChannel = null;
        }
        
        await sb.auth.signOut();
        isAdminAuthenticated = false;
        navigate('home');
      } catch (error) {
        console.error('Erro ao fazer logout:', error);
        showToast('Erro ao fazer logout', 'error');
      }
    }
    
    // ============================================
    // SUPABASE REALTIME
    // ============================================
    function subscribeToEvent(eventId) {
      if (realtimeChannel) {
        sb.removeChannel(realtimeChannel);
      }
      
      realtimeChannel = sb
        .channel(`event-${eventId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'invites',
            filter: `event_id=eq.${eventId}`
          },
          (payload) => {
            console.log('Realtime change:', payload);
            handleRealtimeUpdate(payload);
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'events',
            filter: `id=eq.${eventId}`
          },
          (payload) => {
            console.log('Event update:', payload);
            handleEventUpdate(payload);
          }
        )
        .subscribe((status) => {
          if (status === 'SUBSCRIBED') {
            console.log('Subscrito ao evento:', eventId);
          }
        });
    }
    
    function unsubscribeFromEvent() {
      if (realtimeChannel) {
        sb.removeChannel(realtimeChannel);
        realtimeChannel = null;
      }
    }
    
    async function handleRealtimeUpdate(payload) {
      console.log('üîÑ Realtime update recebido:', payload.eventType);
      
      if (currentView === 'admin' && selectedEventId) {
        await loadInvites(selectedEventId);
        await loadQrCodes(selectedEventId);
        updateInvitesList();
        
        // ‚úÖ Atualizar estat√≠sticas no painel admin tamb√©m
        render();
        setTimeout(async () => {
          if (currentEvent && currentEvent.pdf_path) {
            const pdfBlob = await downloadFile(currentEvent.pdf_path);
            if (pdfBlob) {
              const arrayBuffer = await pdfBlob.arrayBuffer();
              await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
              initDragAndDrop();
            }
          }
        }, 100);
      } else if (currentView === 'client' && currentEvent) {
        // ‚úÖ CORRIGIDO: Recarregar convites do banco de dados
        await loadInvites(currentEvent.id);
        await loadQrCodes(currentEvent.id);
        
        // ‚úÖ CR√çTICO: For√ßar re-render completo da se√ß√£o de convites gerados
        const clientSection = document.querySelector('#clientInvitesList');
        if (clientSection) {
          const eventInvites = invites.filter(i => i.event_id === currentEvent.id);
          
          if (eventInvites.length > 0) {
            // Mostrar a se√ß√£o se estava escondida
            const section = clientSection.parentElement;
            if (section) {
              section.style.display = 'block';
            }
            
            // Re-renderizar a lista completa
            clientSection.innerHTML = eventInvites.map(invite => `
              <div class="flex items-center justify-between bg-gray-50 px-4 py-3 rounded-lg">
                <span class="font-medium text-gray-800">${invite.guest_name}</span>
                <button 
                  onclick="handleClientRedownload('${currentEvent.id}', '${invite.guest_name}')"
                  class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm transition">
                  ‚¨á Baixar
                </button>
              </div>
            `).join('');
            
            // Atualizar o contador do t√≠tulo
            const titleElement = section.querySelector('h3');
            if (titleElement) {
              titleElement.textContent = `Convites Gerados (${eventInvites.length})`;
            }
          }
        }
        
        // ‚úÖ Atualizar estat√≠sticas (dispon√≠veis/gerados)
        updateClientStats();
        
        console.log('‚úÖ Convites atualizados em tempo real:', invites.length);
      }
    }
    
    async function handleEventUpdate(payload) {
      await loadEvent(selectedEventId);
      
      if (currentView === 'admin' && selectedEventId === payload.new.id) {
        render();
        
        setTimeout(async () => {
          if (currentEvent && currentEvent.pdf_path) {
            const pdfBlob = await downloadFile(currentEvent.pdf_path);
            if (pdfBlob) {
              const arrayBuffer = await pdfBlob.arrayBuffer();
              await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
              initDragAndDrop();
            }
          }
        }, 100);
      }
    }
    
    // ============================================
    // TOKENS M√öLTIPLOS
    // ============================================
    let eventTokens = [];
    
    async function loadEventTokens(eventId) {
      try {
        const { data, error } = await sb
          .from('event_tokens')
          .select('*')
          .eq('event_id', eventId)
          .order('created_at', { ascending: true });
        
        if (error) throw error;
        
        eventTokens = data || [];
        return eventTokens;
      } catch (error) {
        console.error('Erro ao carregar tokens:', error);
        showToast('Erro ao carregar tokens', 'error');
        return [];
      }
    }
    
    async function createEventToken(eventId, tokenData) {
      try {
        const { data, error } = await sb
          .from('event_tokens')
          .insert([{
            event_id: eventId,
            token: tokenData.token,
            token_name: tokenData.token_name,
            max_invites: tokenData.max_invites,
            active: true
          }])
          .select()
          .single();
        
        if (error) throw error;
        
        showToast('Token criado com sucesso!');
        return data;
      } catch (error) {
        console.error('Erro ao criar token:', error);
        showToast('Erro ao criar token', 'error');
        return null;
      }
    }
    
    async function updateEventToken(tokenId, updates) {
      try {
        const { data, error } = await sb
          .from('event_tokens')
          .update(updates)
          .eq('id', tokenId)
          .select()
          .single();
        
        if (error) throw error;
        
        return data;
      } catch (error) {
        console.error('Erro ao atualizar token:', error);
        showToast('Erro ao atualizar token', 'error');
        return null;
      }
    }
    
    async function deleteEventToken(tokenId) {
      try {
        const { error } = await sb
          .from('event_tokens')
          .delete()
          .eq('id', tokenId);
        
        if (error) throw error;
        
        showToast('Token eliminado');
        return true;
      } catch (error) {
        console.error('Erro ao eliminar token:', error);
        showToast('Erro ao eliminar token', 'error');
        return false;
      }
    }
    
    async function getTokenStats(tokenId) {
      try {
        const { data, error } = await sb
          .from('invites')
          .select('id')
          .eq('token_id', tokenId);
        
        if (error) throw error;
        
        return data ? data.length : 0;
      } catch (error) {
        console.error('Erro ao buscar estat√≠sticas do token:', error);
        return 0;
      }
    }
    
    async function loadEventByTokenString(tokenString) {
      try {
        if (!validateToken(tokenString)) {
          console.error('Token inv√°lido na valida√ß√£o:', tokenString);
          showToast('Token inv√°lido', 'error');
          return null;
        }
        
        console.log('Buscando token:', tokenString);
        
        // Buscar o token na tabela event_tokens
        const { data: tokenData, error: tokenError } = await sb
          .from('event_tokens')
          .select('*, events(*)')
          .eq('token', tokenString)
          .single();
        
        if (tokenError) {
          if (tokenError.code === 'PGRST116') {
            // Token n√£o encontrado em event_tokens, buscar no token principal do evento
            const { data: eventData, error: eventError } = await sb
              .from('events')
              .select('*')
              .eq('token', tokenString)
              .single();
            
            if (eventError) {
              console.error('Token n√£o encontrado:', tokenString);
              showToast('Token n√£o encontrado', 'error');
              return null;
            }
            
            console.log('Evento encontrado (token principal):', eventData);
            return { event: eventData, tokenData: null };
          } else {
            throw tokenError;
          }
        }
        
        console.log('Token encontrado:', tokenData);
        return { event: tokenData.events, tokenData: tokenData };
      } catch (error) {
        console.error('Erro ao carregar evento por token:', error);
        showToast('Erro ao carregar evento: ' + error.message, 'error');
        return null;
      }
    }
    
    // ============================================
    // EVENTOS - CRUD SUPABASE
    // ============================================
    async function loadEvents() {
      try {
        const { data, error } = await sb
          .from('events')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        events = data || [];
        return events;
      } catch (error) {
        console.error('Erro ao carregar eventos:', error);
        showToast('Erro ao carregar eventos', 'error');
        return [];
      }
    }
    
    async function loadEvent(eventId) {
      try {
        const { data, error } = await sb
          .from('events')
          .select('*')
          .eq('id', eventId)
          .single();
        
        if (error) throw error;
        
        currentEvent = data;
        return data;
      } catch (error) {
        console.error('Erro ao carregar evento:', error);
        showToast('Erro ao carregar evento', 'error');
        return null;
      }
    }
    
    async function loadEventByToken(token) {
      try {
        if (!validateToken(token)) {
          console.error('Token inv√°lido na valida√ß√£o:', token);
          showToast('Token inv√°lido', 'error');
          return null;
        }
        
        console.log('Buscando evento com token:', token);
        
        const { data, error } = await sb
          .from('events')
          .select('*')
          .eq('token', token)
          .single();
        
        console.log('Resultado da busca:', { data, error });
        
        if (error) {
          if (error.code === 'PGRST116') {
            console.error('Token n√£o encontrado no banco:', token);
            showToast('Token n√£o encontrado', 'error');
          } else {
            console.error('Erro no Supabase:', error);
            throw error;
          }
          return null;
        }
        
        console.log('Evento encontrado:', data);
        return data;
      } catch (error) {
        console.error('Erro ao carregar evento por token:', error);
        
        if (error.code === 'PGRST301') {
          showToast('Erro de liga  √£o √† base de dados. Tente novamente', 'error');
        } else if (error.message.includes('JWT') || error.message.includes('auth')) {
          showToast('Erro de autentica√ß√£o. Recarregue a p√°gina', 'error');
        } else {
          showToast('Erro ao carregar evento: ' + error.message, 'error');
        }
        
        return null;
      }
    }
    
    async function createEvent(eventData) {
      try {
        const { data, error } = await sb
          .from('events')
          .insert([{
            event_name: eventData.event_name,
            token: eventData.token,
            active: true,
            pdf_path: eventData.pdf_path || '',
            font_path: eventData.font_path || '',
            font_name: eventData.font_name || '',
            page_number: 1,
            position_x_pt: 100,
            position_y_pt: 100,
            font_size: 24,
            text_color: '#000000',
            text_transform: 'none',
            text_alignment: 'left',
            anchor_position: 'left',
            max_invites: eventData.max_invites || 100,
            qr_enabled: false,
            qr_position_x_pt: 100,
            qr_position_y_pt: 100,
            qr_size_pt: 100,
            qr_delete_after_use: true
          }])
          .select()
          .single();
        
        if (error) throw error;
        
        showToast('Evento criado com sucesso!');
        tempPdfBytes = null;
        tempFontBytes = null;
        tempFontName = null;
        return data;
      } catch (error) {
        console.error('Erro ao criar evento:', error);
        showToast('Erro ao criar evento', 'error');
        return null;
      }
    }
    
    async function updateEvent(eventId, updates) {
      try {
        const { data, error } = await sb
          .from('events')
          .update(updates)
          .eq('id', eventId)
          .select()
          .single();
        
        if (error) throw error;
        
        currentEvent = data;
        const index = events.findIndex(e => e.id === eventId);
        if (index !== -1) {
          events[index] = data;
        }
        
        return data;
      } catch (error) {
        console.error('Erro ao atualizar evento:', error);
        showToast('Erro ao atualizar evento', 'error');
        return null;
      }
    }
    
    async function deleteEvent(eventId) {
      try {
        const { error: invitesError } = await sb
          .from('invites')
          .delete()
          .eq('event_id', eventId);
        
        if (invitesError) throw invitesError;
        
        const { error } = await sb
          .from('events')
          .delete()
          .eq('id', eventId);
        
        if (error) throw error;
        
        showToast('Evento eliminado');
        
        if (selectedEventId === eventId) {
          selectedEventId = null;
          currentEvent = null;
          unsubscribeFromEvent();
        }
        
        await loadEvents();
        render();
        
        return true;
      } catch (error) {
        console.error('Erro ao eliminar evento:', error);
        showToast('Erro ao eliminar evento', 'error');
        return false;
      }
    }
    
    async function toggleEventActive(eventId) {
      try {
        const event = events.find(e => e.id === eventId);
        if (!event) return;
        
        await updateEvent(eventId, { active: !event.active });
      } catch (error) {
        console.error('Erro ao alternar estado do evento:', error);
        showToast('Erro ao alternar estado do evento', 'error');
      }
    }
    
    // ============================================
    // QR CODES - CRUD SUPABASE
    // ============================================
    async function loadQrCodes(eventId) {
      try {
        const { data, error } = await sb
          .from('qr_codes')
          .select('*')
          .eq('event_id', eventId)
          .order('created_at', { ascending: true });
        
        if (error) throw error;
        
        qrCodes = data || [];
        return qrCodes;
      } catch (error) {
        console.error('Erro ao carregar QR codes:', error);
        showToast('Erro ao carregar QR codes', 'error');
        return [];
      }
    }
    
    async function uploadQrCodes(eventId, files) {
      try {
        if (files.length < 1 || files.length > 400) {
          showToast('Deve enviar entre 1 e 400 QR codes', 'error');
          return false;
        }
        
        const event = await loadEvent(eventId);
        if (!event) {
          showToast('Evento n√£o encontrado', 'error');
          return false;
        }
        
        const existingQrs = await loadQrCodes(eventId);
        const totalQrs = existingQrs.length + files.length;
        
        if (totalQrs > 400) {
          showToast(`Limite de 400 QR codes excedido. J√° existem ${existingQrs.length} QR codes`, 'error');
          return false;
        }
        
        const uploadedQrs = [];
        
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          
          if (!file.type.startsWith('image/')) {
            console.warn(`${file.name} n√£o √© uma imagem v√°lida, ignorando...`);
            continue;
          }
          
          try {
            const base64String = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = () => reject(new Error(`Erro ao ler ${file.name}`));
              reader.readAsDataURL(file);
            });
            
            if (base64String && typeof base64String === 'string' && base64String.length > 0) {
              uploadedQrs.push({
                event_id: eventId,
                image_base64: base64String,
                used: false
              });
            } else {
              console.error(`Base64 inv√°lido para ${file.name}`);
            }
          } catch (readError) {
            console.error(`Erro ao processar ${file.name}:`, readError);
            continue;
          }
        }
        
        if (uploadedQrs.length > 0) {
          console.log(`Tentando inserir ${uploadedQrs.length} QR codes...`);
          
          const { data, error } = await sb
            .from('qr_codes')
            .insert(uploadedQrs)
            .select();
          
          if (error) {
            console.error('Erro do Supabase:', error);
            throw error;
          }
          
          console.log('QR codes inseridos com sucesso:', data);
          
          showToast(`${uploadedQrs.length} QR code${uploadedQrs.length > 1 ? 's' : ''} carregado${uploadedQrs.length > 1 ? 's' : ''} com sucesso!`);
          
          return true;
        } else {
          showToast('Nenhum QR code v√°lido foi processado', 'error');
          return false;
        }
      } catch (error) {
        console.error('Erro ao fazer upload de QR codes:', error);
        showToast('Erro ao fazer upload de QR codes: ' + (error.message || JSON.stringify(error)), 'error');
        return false;
      }
    }
    
    async function deleteQrCode(qrId) {
      try {
        const { error } = await sb
          .from('qr_codes')
          .delete()
          .eq('id', qrId);
        
        if (error) throw error;
        
        showToast('QR code eliminado');
        return true;
      } catch (error) {
        console.error('Erro ao eliminar QR code:', error);
        showToast('Erro ao eliminar QR code', 'error');
        return false;
      }
    }
    
    async function deleteAllQrCodes(eventId) {
      try {
        const { error } = await sb
          .from('qr_codes')
          .delete()
          .eq('event_id', eventId);
        
        if (error) throw error;
        
        showToast('QR codes eliminados');
        return true;
      } catch (error) {
        console.error('Erro ao eliminar QR codes:', error);
        showToast('Erro ao eliminar QR codes', 'error');
        return false;
      }
    }
    
    async function getNextAvailableQrCode(eventId) {
      try {
        const { data, error } = await sb
          .from('qr_codes')
          .select('*')
          .eq('event_id', eventId)
          .eq('used', false)
          .limit(1)
          .single();
        
        if (error) {
          if (error.code === 'PGRST116') {
            return null;
          }
          throw error;
        }
        
        return data;
      } catch (error) {
        console.error('Erro ao buscar QR code dispon√≠vel:', error);
        return null;
      }
    }
    
    async function markQrCodeAsUsed(qrId, inviteId) {
      try {
        // ‚úÖ Marcar QR code como usado E associar ao convite (n√£o eliminar)
        // Isso permite que o cliente baixe novamente o mesmo convite com o mesmo QR code
        const { error } = await sb
          .from('qr_codes')
          .update({ 
            used: true,
            invite_id: inviteId,
            used_at: new Date().toISOString()
          })
          .eq('id', qrId);
        
        if (error) throw error;
        
        console.log(`‚úÖ QR code ${qrId} marcado como usado no convite ${inviteId}`);
        
        return true;
      } catch (error) {
        console.error('Erro ao marcar QR code como usado:', error);
        return false;
      }
    }
    
    // ============================================
    // CONVITES - CRUD SUPABASE
    // ============================================
    async function loadInvites(eventId) {
      try {
        const { data, error } = await sb
          .from('invites')
          .select('*')
          .eq('event_id', eventId)
          .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        invites = data || [];
        return invites;
      } catch (error) {
        console.error('Erro ao carregar convites:', error);
        showToast('Erro ao carregar convites', 'error');
        return [];
      }
    }
    
    async function createInviteInDatabase(eventId, guestName, qrCodeId = null, tokenId = null) {
      try {
        // VALIDA√á√ÉO E CRIA√á√ÉO NO BACKEND
        // Esta fun√ß√£o cria o convite no banco ANTES de gerar o PDF
        const { data: validationData, error: validationError } = await sb
          .rpc('validate_and_create_invite', {
            p_event_id: eventId,
            p_guest_name: guestName,
            p_qr_code_id: qrCodeId,
            p_token_id: tokenId
          });
        
        if (validationError) {
          console.error('Erro de valida√ß√£o:', validationError);
          
          // Mensagens espec  ficas baseadas no erro do backend
          if (validationError.message.includes('limit reached')) {
            showToast('Limite m√°ximo de convites atingido', 'error');
          } else if (validationError.message.includes('event not found')) {
            showToast('Evento n√£o encontrado', 'error');
          } else if (validationError.message.includes('event inactive')) {
            showToast('Evento inativo', 'error');
          } else if (validationError.message.includes('duplicate name')) {
            showToast('Nome j√° registado neste evento', 'error');
          } else {
            showToast('Erro ao criar convite: ' + validationError.message, 'error');
          }
          
          return null;
        }
        
        // Retornar o convite criado pelo backend
        return validationData;
      } catch (error) {
        console.error('Erro ao criar convite:', error);
        showToast('Erro ao criar convite', 'error');
        return null;
      }
    }
    
    async function deleteInvite(inviteId) {
      try {
        const { error } = await sb
          .from('invites')
          .delete()
          .eq('id', inviteId);
        
        if (error) throw error;
        
        showToast('Convite eliminado');
        
        if (selectedEventId) {
          await loadInvites(selectedEventId);
          updateInvitesList();
        }
        
        return true;
      } catch (error) {
        console.error('Erro ao eliminar convite:', error);
        showToast('Erro ao eliminar convite', 'error');
        return false;
      }
    }
    
    // ============================================
    // STORAGE SUPABASE
    // ============================================
    async function uploadPdf(eventId, pdfBytes) {
      try {
        const path = `events/${eventId}/base.pdf`;
        
        const { error } = await sb.storage
          .from('invites')
          .upload(path, pdfBytes, {
            contentType: 'application/pdf',
            upsert: true
          });
        
        if (error) throw error;
        
        return path;
      } catch (error) {
        console.error('Erro ao fazer upload do PDF:', error);
        
        if (error.message.includes('storage')) {
          showToast('Erro no armazenamento. Verifique as permiss√µes do bucket', 'error');
        } else if (error.message.includes('size') || error.message.includes('payload')) {
          showToast('Ficheiro demasiado grande. O PDF deve ter no m√°ximo 10MB', 'error');
        } else {
          showToast('Erro ao fazer upload do PDF: ' + error.message, 'error');
        }
        
        return null;
      }
    }
    
    async function uploadFont(eventId, fontBytes, fontName) {
      try {
        const path = `events/${eventId}/font.ttf`;
        
        const { error } = await sb.storage
          .from('invites')
          .upload(path, fontBytes, {
            contentType: 'font/ttf',
            upsert: true
          });
        
        if (error) throw error;
        
        return path;
      } catch (error) {
        console.error('Erro ao fazer upload da fonte:', error);
        
        if (error.message.includes('storage')) {
          showToast('Erro no armazenamento. Verifique as permiss√µes do bucket', 'error');
        } else if (error.message.includes('type')) {
          showToast('Formato de fonte inv√°lido. Use apenas .ttf ou .otf', 'error');
        } else {
          showToast('Erro ao fazer upload da fonte: ' + error.message, 'error');
        }
        
        return null;
      }
    }
    
    async function downloadFile(path) {
      try {
        const { data, error } = await sb.storage
          .from('invites')
          .download(path);
        
        if (error) throw error;
        
        return data;
      } catch (error) {
        console.error('Erro ao fazer download do ficheiro:', error);
        
        if (error.message.includes('not found') || error.statusCode === 404) {
          showToast('Ficheiro n√£o encontrado no armazenamento', 'error');
        } else if (error.message.includes('permission') || error.statusCode === 403) {
          showToast('Sem permiss√£o para aceder ao ficheiro', 'error');
        } else {
          showToast('Erro ao fazer download: ' + error.message, 'error');
        }
        
        return null;
      }
    }
    
    // ============================================
    // CONVERS√ÉO PT ‚Üí PX (FONTE √öNICA DA VERDADE)
    // ============================================
    function ptToPx(ptX, ptY, canvas, pdfPage) {
      return {
        x: (ptX / pdfPage.width) * canvas.width,
        y: canvas.height - ((ptY / pdfPage.height) * canvas.height)
      };
    }
    
    function pxToPt(pxX, pxY, canvas, pdfPage) {
      return {
        x: (pxX / canvas.width) * pdfPage.width,
        y: pdfPage.height - ((pxY / canvas.height) * pdfPage.height)
      };
    }
    
    // ============================================
    // RENDERIZA√á√ÉO PDF NO CANVAS
    // ============================================
    async function renderPdfOnCanvas(pdfBytes, pageNumber = 1) {
      const canvas = document.getElementById('pdfCanvas');
      if (!canvas) return;
      
      if (currentRenderTask) {
        try {
          currentRenderTask.cancel();
        } catch (e) {
          // Ignorar
        }
      }
      
      try {
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        const pdf = await loadingTask.promise;
        
        const numPages = pdf.numPages;
        if (pageNumber < 1 || pageNumber > numPages) {
          showToast(`P√°gina ${pageNumber} n√£o existe. O PDF tem ${numPages} p√°gina${numPages !== 1 ? 's' : ''}. A mostrar p√°gina 1.`, 'error');
          
          if (selectedEventId) {
            await updateEvent(selectedEventId, { page_number: 1 });
          }
          
          pageNumber = 1;
        }
        
        const page = await pdf.getPage(pageNumber);
        
        const viewport = page.getViewport({ scale: canvasScale });
        const context = canvas.getContext('2d');
        
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        pdfPageDimensions = {
          width: page.view[2] - page.view[0],
          height: page.view[3] - page.view[1]
        };
        
        const renderContext = {
          canvasContext: context,
          viewport: viewport
        };
        
        currentRenderTask = page.render(renderContext);
        await currentRenderTask.promise;
        currentRenderTask = null;
        
        repositionDraggableText();
        
      } catch (error) {
        if (error.name !== 'RenderingCancelledException') {
          console.error('Erro ao renderizar PDF no canvas:', error);
          
          if (error.message.includes('Invalid PDF')) {
            showToast('O ficheiro PDF est√° corrompido ou inv√°lido', 'error');
          } else if (error.message.includes('password')) {
            showToast('O PDF est√° protegido por palavra-passe', 'error');
          } else if (error.message.includes('page')) {
            showToast('Erro ao aceder √† p√°gina do PDF', 'error');
          } else {
            showToast('Erro ao visualizar o PDF: ' + error.message, 'error');
          }
        }
      }
    }
    
    async function repositionDraggableText() {
      const textElement = document.getElementById('draggableText');
      if (!textElement || !currentEvent) return;
      
      const canvas = document.getElementById('pdfCanvas');
      if (!canvas) return;
      
      let displayText = 'Nome Exemplo';
      if (currentEvent.text_transform === 'uppercase') {
        displayText = displayText.toUpperCase();
      } else if (currentEvent.text_transform === 'lowercase') {
        displayText = displayText.toLowerCase();
      } else if (currentEvent.text_transform === 'capitalize') {
        displayText = displayText.split(' ').map(w => 
          w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
        ).join(' ');
      }
      
      textElement.textContent = displayText;
      
      const { x, y } = ptToPx(
        currentEvent.position_x_pt,
        currentEvent.position_y_pt,
        canvas,
        pdfPageDimensions
      );
      
      let previewX = x;
      
      if (currentEvent.anchor_position === 'center') {
        previewX = x - (textElement.offsetWidth / 2);
      } else if (currentEvent.anchor_position === 'right') {
        previewX = x - textElement.offsetWidth;
      }
      
      textElement.style.left = `${previewX}px`;
      textElement.style.top = `${y}px`;
      
      if (currentEvent.qr_enabled) {
        repositionDraggableQr();
      }
    }
    
    function repositionDraggableQr() {
      const qrElement = document.getElementById('draggableQr');
      if (!qrElement || !currentEvent) return;
      
      const canvas = document.getElementById('pdfCanvas');
      if (!canvas) return;
      
      const { x, y } = ptToPx(
        currentEvent.qr_position_x_pt,
        currentEvent.qr_position_y_pt,
        canvas,
        pdfPageDimensions
      );
      
      const qrPxSize = (currentEvent.qr_size_pt / pdfPageDimensions.width) * canvas.width;
      
      qrElement.style.left = `${x}px`;
      qrElement.style.top = `${y}px`;
      qrElement.style.width = `${qrPxSize}px`;
      qrElement.style.height = `${qrPxSize}px`;
    }
    
    // ============================================
    // PREVIEW EM TEMPO REAL
    // ============================================
    function updateTextPreview(property, value) {
      const textElement = document.getElementById('draggableText');
      if (!textElement || !currentEvent) return;
      
      // Atualizar propriedade temporariamente no currentEvent
      const tempEvent = { ...currentEvent };
      tempEvent[property] = value;
      
      // Aplicar transforma√ß√£o de texto
      let displayText = 'Nome Exemplo';
      if (tempEvent.text_transform === 'uppercase') {
        displayText = displayText.toUpperCase();
      } else if (tempEvent.text_transform === 'lowercase') {
        displayText = displayText.toLowerCase();
      } else if (tempEvent.text_transform === 'capitalize') {
        displayText = displayText.split(' ').map(w => 
          w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
        ).join(' ');
      }
      
      textElement.textContent = displayText;
      
      // Aplicar estilo
      if (property === 'font_size') {
        textElement.style.fontSize = `${value}px`;
      } else if (property === 'text_color') {
        textElement.style.color = value;
      }
      
      // ‚úÖ SEMPRE reposicionar quando o tamanho da fonte muda
      // Isso garante que o texto cres√ßa dos dois lados (esquerda e direita)
      if (property === 'anchor_position' || property === 'font_size') {
        const canvas = document.getElementById('pdfCanvas');
        if (!canvas) return;
        
        // ‚úÖ For  ar o navegador a recalcular o width ANTES de reposicionar
        void textElement.offsetWidth;
        
        const { x, y } = ptToPx(
          tempEvent.position_x_pt,
          tempEvent.position_y_pt,
          canvas,
          pdfPageDimensions
        );
        
        let previewX = x;
        
        if (tempEvent.anchor_position === 'center') {
          previewX = x - (textElement.offsetWidth / 2);
        } else if (tempEvent.anchor_position === 'right') {
          previewX = x - textElement.offsetWidth;
        }
        
        textElement.style.left = `${previewX}px`;
        textElement.style.top = `${y}px`;
      }
    }
    
    function updateQrPreview(size) {
      const qrElement = document.getElementById('draggableQr');
      if (!qrElement || !currentEvent) return;
      
      const canvas = document.getElementById('pdfCanvas');
      if (!canvas) return;
      
      const qrPxSize = (size / pdfPageDimensions.width) * canvas.width;
      
      qrElement.style.width = `${qrPxSize}px`;
      qrElement.style.height = `${qrPxSize}px`;
      qrElement.innerHTML = `QR CODE<br>${size}pt`;
    }
    
    // ============================================
    // DRAG & DROP
    // ============================================
    function initDragAndDrop() {
      setTimeout(() => {
        const textElement = document.getElementById('draggableText');
        if (textElement) {
          textElement.addEventListener('mousedown', startDrag);
          textElement.addEventListener('touchstart', startDrag, { passive: false });
        }
        
        const qrElement = document.getElementById('draggableQr');
        if (qrElement) {
          qrElement.addEventListener('mousedown', startDrag);
          qrElement.addEventListener('touchstart', startDrag, { passive: false });
        }
        
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('touchend', endDrag);
      }, 100);
    }
    
    function startResize(e) {
      e.preventDefault();
      e.stopPropagation();
      
      isResizing = true;
      const qrElement = document.getElementById('draggableQr');
      if (!qrElement) return;
      
      const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
      const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      
      resizeStartSize = qrElement.offsetWidth;
      resizeStartX = clientX;
      resizeStartY = clientY;
    }
    
    function startDrag(e) {
      if (isResizing) return;
      
      e.preventDefault();
      draggedElement = e.target;
      
      const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
      const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      
      const rect = draggedElement.getBoundingClientRect();
      dragOffsetX = clientX - rect.left;
      dragOffsetY = clientY - rect.top;
    }
    
    function drag(e) {
      if (isResizing) {
        const qrElement = document.getElementById('draggableQr');
        if (!qrElement) return;
        
        e.preventDefault();
        
        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        
        const deltaX = clientX - resizeStartX;
        const deltaY = clientY - resizeStartY;
        const delta = Math.max(deltaX, deltaY);
        
        let newSize = resizeStartSize + delta;
        newSize = Math.max(50, Math.min(newSize, 400));
        
        qrElement.style.width = `${newSize}px`;
        qrElement.style.height = `${newSize}px`;
        
        const canvas = document.getElementById('pdfCanvas');
        const qrPtSize = (newSize / canvas.width) * pdfPageDimensions.width;
        qrElement.innerHTML = `QR CODE<br>${Math.round(qrPtSize)}pt<div class="resize-handle bottom-right" onmousedown="startResize(event)" ontouchstart="startResize(event)"></div>`;
        
        return;
      }
      
      if (!draggedElement) return;
      e.preventDefault();
      
      const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
      const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      
      const canvas = document.getElementById('pdfCanvas');
      const canvasRect = canvas.getBoundingClientRect();
      
      let newX = clientX - canvasRect.left - dragOffsetX;
      let newY = clientY - canvasRect.top - dragOffsetY;
      
      newX = Math.max(0, Math.min(newX, canvas.width - draggedElement.offsetWidth));
      newY = Math.max(0, Math.min(newY, canvas.height - draggedElement.offsetHeight));
      
      draggedElement.style.left = `${newX}px`;
      draggedElement.style.top = `${newY}px`;
    }
    
    async function endDrag(e) {
      if (isResizing) {
        const qrElement = document.getElementById('draggableQr');
        if (!qrElement) {
          isResizing = false;
          return;
        }
        
        const canvas = document.getElementById('pdfCanvas');
        const qrPxSize = qrElement.offsetWidth;
        const qrPtSize = (qrPxSize / canvas.width) * pdfPageDimensions.width;
        
        await updateEvent(selectedEventId, {
          qr_size_pt: Math.round(qrPtSize)
        });
        
        isResizing = false;
        return;
      }
      
      if (!draggedElement) return;
      
      const canvas = document.getElementById('pdfCanvas');
      const pxX = parseFloat(draggedElement.style.left);
      const pxY = parseFloat(draggedElement.style.top);
      
      if (draggedElement.id === 'draggableQr') {
        const { x: ptX, y: ptY } = pxToPt(pxX, pxY, canvas, pdfPageDimensions);
        
        await updateEvent(selectedEventId, {
          qr_position_x_pt: ptX,
          qr_position_y_pt: ptY
        });
      } else {
        let anchorPxX = pxX;
        
        if (currentEvent.anchor_position === 'center') {
          anchorPxX = pxX + (draggedElement.offsetWidth / 2);
        } else if (currentEvent.anchor_position === 'right') {
          anchorPxX = pxX + draggedElement.offsetWidth;
        }
        
        const { x: ptX, y: ptY } = pxToPt(anchorPxX, pxY, canvas, pdfPageDimensions);
        
        await updateEvent(selectedEventId, {
          position_x_pt: ptX,
          position_y_pt: ptY
        });
      }
      
      draggedElement = null;
    }
    
    // ============================================
    // GERA√á√ÉO DE PDF
    // ============================================
    async function generateInvitePdf(eventId, guestName, tokenId = null) {
      try {
        const event = await loadEvent(eventId);
        if (!event) {
          showToast('Evento n√£o encontrado na base de dados', 'error');
          return null;
        }
        
        // PASSO 1: Verificar se o convite j√° existe (para re-download)
        const existingInvites = await loadInvites(eventId);
        const existingInvite = existingInvites.find(i => i.guest_name === guestName && i.event_id === eventId);
        
        let qrCodeData = null;
        let invite = existingInvite;
        
        if (existingInvite) {
          // ‚úÖ CONVITE J√Å EXISTE - Re-usar o mesmo QR code associado
          if (event.qr_enabled && existingInvite.qr_code_id) {
            const { data, error } = await sb
              .from('qr_codes')
              .select('*')
              .eq('id', existingInvite.qr_code_id)
              .single();
            
            if (!error && data) {
              qrCodeData = data;
              console.log(`‚úÖ Re-usando QR code ${qrCodeData.id} para convite existente`);
            }
          }
        } else {
          // ‚úÖ NOVO CONVITE - Validar limite ANTES de buscar QR code
          
          // ‚úÖ VALIDA√á√ÉO DE LIMITE BASEADA EM QR CODES
          if (event.qr_enabled) {
            const qrs = await loadQrCodes(eventId);
            const availableQrs = qrs.filter(qr => !qr.used).length;
            
            if (availableQrs === 0) {
              showToast('N√£o h√° QR codes dispon√≠veis para este evento', 'error');
              return null;
            }
            
            // Buscar QR code dispon√≠vel
            qrCodeData = await getNextAvailableQrCode(eventId);
            if (!qrCodeData) {
              showToast('N√£o h√° QR codes dispon√≠veis para este evento', 'error');
              return null;
            }
          } else {
            // ‚úÖ VALIDA√á√ÉO DE LIMITE MANUAL (max_invites)
            if (existingInvites.length >= event.max_invites) {
              showToast(`Limite de ${event.max_invites} convites atingido`, 'error');
              return null;
            }
          }
          
          // ‚úÖ Validar nome duplicado
          const duplicate = existingInvites.find(i => i.guest_name.toLowerCase() === guestName.toLowerCase());
          if (duplicate) {
            showToast('Nome j√° registado neste evento', 'error');
            return null;
          }
          
          // PASSO 2: CRIAR CONVITE NO BANCO
          const { data: newInvite, error: insertError } = await sb
            .from('invites')
            .insert([{
              event_id: eventId,
              guest_name: guestName,
              qr_code_id: qrCodeData ? qrCodeData.id : null,
              token_id: tokenId
            }])
            .select()
            .single();
          
          if (insertError) {
            console.error('Erro ao inserir convite:', insertError);
            showToast('Erro ao criar convite: ' + insertError.message, 'error');
            return null;
          }
          
          invite = newInvite;
        }
        
        // PASSO 3: Convite criado com sucesso, agora gerar o PDF
        const pdfBlob = await downloadFile(event.pdf_path);
        if (!pdfBlob) {
          showToast('Falha ao carregar o PDF base. Convite registado mas PDF n√£o gerado', 'error');
          // Convite j√° foi criado, mas PDF falhou - usu√°rio pode tentar re-baixar
          return null;
        }
        
        const pdfBytes = await pdfBlob.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        
        pdfDoc.registerFontkit(fontkit);
        
        let font;
        try {
          if (event.font_path) {
            const fontBlob = await downloadFile(event.font_path);
            if (fontBlob) {
              const fontBytes = await fontBlob.arrayBuffer();
              font = await pdfDoc.embedFont(fontBytes);
            } else {
              showToast('Fonte personalizada n√£o encontrada. A usar fonte padr  o', 'error');
              font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
            }
          } else {
            font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
          }
        } catch (fontError) {
          console.error('Erro ao carregar fonte personalizada:', fontError);
          showToast('Erro ao carregar fonte personalizada. A usar fonte padr√£o', 'error');
          font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
        }
        
        let displayName = guestName;
        if (event.text_transform === 'uppercase') {
          displayName = displayName.toUpperCase();
        } else if (event.text_transform === 'lowercase') {
          displayName = displayName.toLowerCase();
        } else if (event.text_transform === 'capitalize') {
          displayName = displayName.split(' ').map(w => 
            w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
          ).join(' ');
        }
        
        const pages = pdfDoc.getPages();
        
        if (event.page_number < 1 || event.page_number > pages.length) {
          showToast(`P√°gina ${event.page_number} n√£o existe. O PDF tem ${pages.length} p√°gina${pages.length !== 1 ? 's' : ''}.`, 'error');
          return null;
        }
        
        const page = pages[event.page_number - 1];
        
        const textWidth = font.widthOfTextAtSize(displayName, event.font_size);
        
        let finalX = event.position_x_pt;
        
        if (event.anchor_position === 'center') {
          finalX = event.position_x_pt - (textWidth / 2);
        } else if (event.anchor_position === 'right') {
          finalX = event.position_x_pt - textWidth;
        }
        
        const textHeight = event.font_size;
        
        const r = parseInt(event.text_color.slice(1, 3), 16) / 255;
        const g = parseInt(event.text_color.slice(3, 5), 16) / 255;
        const b = parseInt(event.text_color.slice(5, 7), 16) / 255;
        
        page.drawText(displayName, {
          x: finalX,
          y: event.position_y_pt - textHeight,
          size: event.font_size,
          font: font,
          color: PDFLib.rgb(r, g, b)
        });
        
        if (event.qr_enabled && qrCodeData) {
          try {
            console.log('Processando QR code:', {
              id: qrCodeData.id,
              hasData: !!qrCodeData.image_base64,
              dataType: typeof qrCodeData.image_base64,
              dataLength: qrCodeData.image_base64 ? qrCodeData.image_base64.length : 0,
              dataStart: qrCodeData.image_base64 ? qrCodeData.image_base64.substring(0, 50) : 'null'
            });
            
            if (!qrCodeData.image_base64 || typeof qrCodeData.image_base64 !== 'string') {
              throw new Error('Dados do QR code inv√°lidos (null ou n√£o √© string)');
            }
            
            if (qrCodeData.image_base64.length < 100) {
              throw new Error('QR code muito pequeno ou corrompido');
            }
            
            let base64Data = qrCodeData.image_base64;
            let imageType = 'png';
            
            if (base64Data.includes(',')) {
              const parts = base64Data.split(',');
              const header = parts[0];
              base64Data = parts[1];
              
              if (header.includes('image/png')) {
                imageType = 'png';
              } else if (header.includes('image/jpeg') || header.includes('image/jpg')) {
                imageType = 'jpeg';
              }
            }
            
            base64Data = base64Data.replace(/\s+/g, '');
            
            console.log('Base64 processado:', {
              imageType,
              cleanedLength: base64Data.length,
              firstChars: base64Data.substring(0, 20)
            });
            
            if (!base64Data || base64Data.length < 50) {
              throw new Error('QR code vazio ap√≥s processamento');
            }
            
            if (!/^[A-Za-z0-9+/=]+$/.test(base64Data)) {
              throw new Error('Base64 cont√©m caracteres inv√°lidos');
            }
            
            let qrBytes;
            try {
              qrBytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
            } catch (decodeError) {
              console.error('Erro ao decodificar base64:', decodeError);
              throw new Error('Falha ao decodificar base64: ' + decodeError.message);
            }
            
            console.log('QR bytes decodificados:', qrBytes.length, 'bytes');
            
            let qrImage;
            try {
              if (imageType === 'png') {
                qrImage = await pdfDoc.embedPng(qrBytes);
              } else {
                qrImage = await pdfDoc.embedJpg(qrBytes);
              }
            } catch (embedError) {
              console.error('Erro ao embedar imagem:', embedError);
              try {
                if (imageType === 'png') {
                  qrImage = await pdfDoc.embedJpg(qrBytes);
                } else {
                  qrImage = await pdfDoc.embedPng(qrBytes);
                }
              } catch (secondError) {
                throw new Error('Formato de imagem n√£o suportado ou corrompido');
              }
            }
            
            // ‚úÖ CORRE√á√ÉO: Em PDF, o Y come√ßa de BAIXO para CIMA
            // No canvas, o Y come√ßa do TOPO para BAIXO
            // A posi√ß√£o armazenada (qr_position_y_pt) j√° est√° no sistema do PDF
            // Mas precisamos subtrair a altura do QR code porque drawImage desenha do canto inferior esquerdo
            page.drawImage(qrImage, {
              x: event.qr_position_x_pt,
              y: event.qr_position_y_pt - event.qr_size_pt,
              width: event.qr_size_pt,
              height: event.qr_size_pt
            });
            
            console.log('QR code adicionado com sucesso ao PDF');
            
          } catch (qrError) {
            console.error('Erro ao adicionar QR code:', qrError);
            console.error('QR code data completo:', qrCodeData);
            showToast('Aviso: QR code n√£o p√¥de ser adicionado. Convite gerado sem QR code.', 'error');
          }
        }
        
        const modifiedPdfBytes = await pdfDoc.save();
        
        // PASSO 4: Marcar QR code como usado (SE for novo convite)
        if (qrCodeData && !existingInvite) {
          await markQrCodeAsUsed(qrCodeData.id, invite.id);
        }
        
        return modifiedPdfBytes;
        
      } catch (error) {
        console.error('Erro ao gerar PDF:', error);
        
        if (error.message.includes('pdf-lib')) {
          showToast('Erro ao processar o PDF: ' + error.message, 'error');
        } else if (error.message.includes('font')) {
          showToast('Erro ao processar a fonte: ' + error.message, 'error');
        } else if (error.message.includes('network') || error.message.includes('fetch')) {
          showToast('Erro de liga√ß√£o. Verifique a internet', 'error');
        } else {
          showToast('Erro ao gerar convite: ' + error.message, 'error');
        }
        
        return null;
      }
    }
    
    function downloadPdf(pdfBytes, filename) {
      try {
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Erro ao iniciar download:', error);
        showToast('Falha ao iniciar o download do PDF. Verifique as permiss√µes do navegador', 'error');
      }
    }
    
    // ============================================
    // VIEWS
    // ============================================
    function renderHome() {
      return `
        <div class="flex items-center justify-center min-h-full bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4">
          <div class="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full">
            <div class="text-center mb-8">
              <div class="text-6xl mb-4">üéâ</div>
              <h1 class="text-3xl font-bold text-gray-800 mb-2">Gerador de Convites</h1>
              <p class="text-gray-600">Sistema profissional de convites personalizados</p>
            </div>
            
            <button 
              onclick="navigate('login')"
              class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition mb-4">
              Acesso Administrador
            </button>
            
            <div class="flex items-center my-6">
              <div class="flex-1 border-t border-gray-300"></div>
              <span class="px-4 text-gray-500 text-sm">OU</span>
              <div class="flex-1 border-t border-gray-300"></div>
            </div>
            
            <div class="space-y-4">
              <label for="tokenInput" class="block text-sm font-medium text-gray-700">
                Token do Evento
              </label>
              <input 
                type="text" 
                id="tokenInput"
                placeholder="Insira o token do evento"
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
              
              <button 
                onclick="handleTokenSubmit()"
                class="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                Acessar Convite
              </button>
            </div>
          </div>
        </div>
      `;
    }
    
    function renderLogin() {
      return `
        <div class="flex items-center justify-center min-h-full bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4">
          <div class="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full">
            <button 
              onclick="navigate('home')"
              class="text-gray-600 hover:text-gray-800 mb-6 flex items-center">
              ‚Üê Voltar
            </button>
            
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Login Administrador</h2>
            
            <form onsubmit="handleLogin(event)" class="space-y-4" autocomplete="off">
              <div>
                <label for="email" class="block text-sm font-medium text-gray-700 mb-2">
                  Email
                </label>
                <input 
                  type="email" 
                  id="email"
                  required
                  autocomplete="off"
                  autocorrect="off"
                  autocapitalize="off"
                  spellcheck="false"
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
              </div>
              
              <div>
                <label for="password" class="block text-sm font-medium text-gray-700 mb-2">
                  Palavra-passe
                </label>
                <input 
                  type="password" 
                  id="password"
                  required
                  autocomplete="new-password"
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
              </div>
              
              <button 
                type="submit"
                class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                Entrar
              </button>
            </form>
            
            <div class="mt-6 pt-4 border-t border-gray-200 text-center text-xs text-gray-500">
                 AdKira 2026 Todos os direitos reservados
            </div>
          </div>
        </div>
      `;
    }
    
    function renderAdminCreate() {
      return `
        <div class="flex items-center justify-center min-h-full bg-gray-50 p-4">
          <div class="bg-white rounded-xl shadow-lg p-8 max-w-2xl w-full">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Criar Novo Evento</h2>
            
            <form onsubmit="handleCreateEvent(event)" class="space-y-6">
              <div>
                <label for="eventName" class="block text-sm font-medium text-gray-700 mb-2">
                  Nome do Evento
                </label>
                <input 
                  type="text" 
                  id="eventName"
                  required
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
              </div>
              
              <div>
                <label for="eventToken" class="block text-sm font-medium text-gray-700 mb-2">
                  Token (32 caracteres)
                </label>
                <input 
                  type="text" 
                  id="eventToken"
                  value="${generateSecureToken()}"
                  readonly
                  class="w-full px-4 py-3 bg-gray-100 border border-gray-300 rounded-lg font-mono text-sm">
              </div>
              
              <div>
                <label for="pdfUpload" class="block text-sm font-medium text-gray-700 mb-2">
                  PDF Base (m√°x 10MB)
                </label>
                <input 
                  type="file" 
                  id="pdfUpload"
                  accept=".pdf"
                  required
                  onchange="handlePdfUpload(event)"
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg">
              </div>
              
              <div>
                <label for="maxInvites" class="block text-sm font-medium text-gray-700 mb-2">
                  M√°ximo de Convites
                </label>
                <input 
                  type="number" 
                  id="maxInvites"
                  value="100"
                  min="1"
                  max="10000"
                  required
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
              </div>
              
              <div class="flex gap-4">
                <button 
                  type="button"
                  onclick="navigate('admin')"
                  class="flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-3 px-6 rounded-lg transition">
                  Cancelar
                </button>
                <button 
                  type="submit"
                  class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                  Criar Evento
                </button>
              </div>
            </form>
          </div>
        </div>
      `;
    }
    
    function renderAdmin() {
      const event = currentEvent;
      
      return `
        <div class="flex h-full">
          <div class="w-80 bg-white border-r border-gray-200 overflow-y-auto">
            <div class="p-6 border-b border-gray-200">
              <h2 class="text-xl font-bold text-gray-800">Painel Admin</h2>
              <button 
                onclick="logout()"
                class="mt-2 text-sm text-red-600 hover:text-red-800">
                Sair
              </button>
            </div>
            
            <div class="p-6 space-y-6">
              <div>
                <label class="block text-sm font-semibold text-gray-700 mb-2">
                  Eventos
                </label>
                <select 
                  onchange="handleEventSelect(this.value)"
                  class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                  <option value="">Selecionar evento...</option>
                  ${events.map(e => `
                    <option value="${e.id}" ${e.id === selectedEventId ? 'selected' : ''}>
                      ${e.event_name}
                    </option>
                  `).join('')}
                </select>
                
                <button 
                  onclick="navigate('admin-create')"
                  class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm">
                  + Criar Evento
                </button>
              </div>
              
              ${event ? renderEventSettings(event) : ''}
            </div>
          </div>
          
          <div class="flex-1 overflow-y-auto bg-gray-50">
            ${event ? renderEventMain(event) : `
              <div class="flex items-center justify-center h-full">
                <div class="text-center text-gray-500">
                  <div class="text-6xl mb-4">   </div>
                  <p class="text-xl">Selecione ou crie um evento</p>
                </div>
              </div>
            `}
          </div>
        </div>
      `;
    }
    
    function renderEventSettings(event) {
      const qrStats = qrCodes.filter(qr => qr.event_id === event.id);
      const availableQrs = qrStats.filter(qr => !qr.used).length; // ‚úÖ Apenas QR codes n√£o usados
      const totalQrs = qrStats.length;
      const usedQrs = qrStats.filter(qr => qr.used).length;
      
      return `
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Nome do Evento
            </label>
            <input 
              type="text" 
              value="${event.event_name}"
              onchange="updateEvent('${event.id}', { event_name: this.value })"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              P√°gina do PDF
            </label>
            <input 
              type="number" 
              value="${event.page_number}"
              min="1"
              onchange="handlePageChange(this.value)"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Tamanho da Fonte
            </label>
            <input 
              type="number" 
              value="${event.font_size}"
              min="8"
              max="200"
              oninput="updateTextPreview('font_size', parseInt(this.value))"
              onchange="updateEvent('${event.id}', { font_size: parseInt(this.value) })"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Cor do Texto
            </label>
            <input 
              type="color" 
              value="${event.text_color}"
              oninput="updateTextPreview('text_color', this.value)"
              onchange="updateEvent('${event.id}', { text_color: this.value })"
              class="w-full h-10 border border-gray-300 rounded-lg">
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Transforma√ß√£o
            </label>
            <select 
              oninput="updateTextPreview('text_transform', this.value)"
              onchange="updateEvent('${event.id}', { text_transform: this.value })"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
              <option value="none" ${event.text_transform === 'none' ? 'selected' : ''}>Nenhuma</option>
              <option value="uppercase" ${event.text_transform === 'uppercase' ? 'selected' : ''}>MAI√öSCULAS</option>
              <option value="lowercase" ${event.text_transform === 'lowercase' ? 'selected' : ''}>min  sculas</option>
              <option value="capitalize" ${event.text_transform === 'capitalize' ? 'selected' : ''}>Capitalizado</option>
            </select>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              √Çncora do Texto
            </label>
            <select 
              oninput="updateTextPreview('anchor_position', this.value)"
              onchange="updateEvent('${event.id}', { anchor_position: this.value })"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
              <option value="left" ${event.anchor_position === 'left' ? 'selected' : ''}>In√≠cio do Texto</option>
              <option value="center" ${event.anchor_position === 'center' ? 'selected' : ''}>Centro do Texto</option>
              <option value="right" ${event.anchor_position === 'right' ? 'selected' : ''}>Fim do Texto</option>
            </select>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              M√°ximo de Convites
            </label>
            <input 
              type="number" 
              value="${event.max_invites}"
              min="1"
              max="10000"
              onchange="handleMaxInvitesChange('${event.id}', parseInt(this.value))"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
            <p class="text-xs text-gray-500 mt-1">
              ${event.qr_enabled ? 
                `${availableQrs} dispon√≠ve${availableQrs !== 1 ? 'is' : 'l'} / ${totalQrs} total (${usedQrs} usado${usedQrs !== 1 ? 's' : ''})` : 
                'Manual (QR codes desativados)'}
            </p>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              PDF Base
            </label>
            <input 
              type="file" 
              accept=".pdf"
              onchange="handlePdfReupload(event)"
              class="w-full text-sm">
            <p class="text-xs text-gray-500 mt-1">
              ${event.pdf_path ? '‚úì PDF carregado. Escolha novo PDF para substituir' : 'Nenhum PDF carregado'}
            </p>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Fonte Personalizada
            </label>
            <input 
              type="file" 
              accept=".ttf,.otf"
              onchange="handleFontUpload(event)"
              class="w-full text-sm">
            ${event.font_name ? `<p class="text-xs text-gray-500 mt-1">Atual: ${event.font_name}</p>` : ''}
          </div>
          
          <div class="border-t border-gray-200 pt-4">
            <div class="flex items-center justify-between mb-3">
              <label class="flex items-center">
                <input 
                  type="checkbox" 
                  ${event.multiple_tokens ? 'checked' : ''}
                  onchange="toggleMultipleTokens('${event.id}', this.checked)"
                  class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                <span class="ml-2 text-sm font-medium text-gray-700">
                  M√∫ltiplos Tokens
                </span>
              </label>
            </div>
            
            ${event.multiple_tokens ? `
              <div class="bg-gradient-to-br from-blue-50 to-indigo-50 p-4 rounded-lg border-2 border-indigo-200 space-y-3">
                <div class="flex items-center justify-between">
                  <h4 class="text-sm font-bold text-indigo-700">üìã Tokens do Evento</h4>
                  <button 
                    onclick="showCreateTokenModal('${event.id}')"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-xs transition">
                    + Criar Token
                  </button>
                </div>
                
                <div id="tokensList" class="space-y-2">
                  ${eventTokens.length === 0 ? `
                    <p class="text-xs text-gray-500 text-center py-2">Nenhum token criado</p>
                  ` : ''}
                </div>
              </div>
            ` : `
              <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p class="text-xs text-blue-800">
                  üí° <strong>Ative M√∫ltiplos Tokens</strong> para criar links separados com limites individuais (exemplo: um token para cada noivo)
                </p>
              </div>
            `}
          </div>
          
          <div class="border-t border-gray-200 pt-4">
            <div class="flex items-center justify-between mb-3">
              <label class="flex items-center">
                <input 
                  type="checkbox" 
                  ${event.qr_enabled ? 'checked' : ''}
                  onchange="toggleQrEnabled('${event.id}', this.checked)"
                  class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                <span class="ml-2 text-sm font-medium text-gray-700">
                  QR Codes Ativados
                </span>
              </label>
              <span class="text-xs text-gray-500">
                ${event.qr_enabled ? `${availableQrs} dispon√≠ve${availableQrs !== 1 ? 'is' : 'l'}` : ''}
              </span>
            </div>
            
            ${!event.qr_enabled ? `
              <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p class="text-xs text-blue-800">
                  üí° <strong>Ative os QR Codes</strong> para fazer upload de imagens QR personalizadas que ser√£o automaticamente inseridas nos convites
                </p>
              </div>
            ` : ''}
            
            ${event.qr_enabled ? `
              <div class="space-y-3 bg-gradient-to-br from-indigo-50 to-purple-50 p-4 rounded-lg border-2 border-indigo-200">
                <div class="bg-blue-50 border border-blue-300 p-3 rounded-lg">
                  <p class="text-xs text-blue-800 font-medium">
                    üí° <strong>Importante:</strong> Cada QR code √© usado uma vez por convite. O cliente pode baixar o mesmo convite novamente com o mesmo QR code.
                  </p>
                </div>
                
                <div class="bg-white p-3 rounded-lg border border-gray-200">
                  <p class="text-xs text-gray-700">
                    üìä <strong>Estat  sticas:</strong><br>
                    ‚Ä¢ Dispon√≠veis: <span class="font-bold text-green-600">${availableQrs}</span><br>
                    ‚Ä¢ Usados: <span class="font-bold text-orange-600">${usedQrs}</span><br>
                    ‚Ä¢ Total: <span class="font-bold text-indigo-600">${totalQrs}</span>
                  </p>
                </div>
                
                <div>
                  <label class="block text-xs font-medium text-gray-700 mb-1">
                    Tamanho do QR (pontos)
                  </label>
                  <input 
                    type="number" 
                    value="${event.qr_size_pt}"
                    min="50"
                    max="300"
                    oninput="updateQrPreview(parseInt(this.value))"
                    onchange="updateEvent('${event.id}', { qr_size_pt: parseInt(this.value) })"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
                </div>
                
                <div class="bg-white p-3 rounded-lg border-2 border-dashed border-indigo-300">
                  <label class="block text-sm font-bold text-indigo-700 mb-2">
                    üì§ Upload de QR Codes
                  </label>
                  <input 
                    type="file" 
                    multiple
                    accept="image/png,image/jpeg,image/jpg"
                    onchange="handleQrCodesUpload(event)"
                    class="w-full text-sm border border-gray-300 rounded-lg p-2 cursor-pointer hover:border-indigo-500 focus:border-indigo-500">
                  <p class="text-xs text-gray-600 mt-2">
                    ‚úì Formatos: PNG, JPG<br>
                    ‚úì Quantidade: 1 a 400 imagens<br>
                    ‚úì Atual: <strong>${totalQrs}</strong> QR code${totalQrs !== 1 ? 's' : ''} carregado${totalQrs !== 1 ? 's' : ''}
                  </p>
                </div>
                
                ${qrStats.length > 0 ? `
                  <button 
                    onclick="confirmDeleteAllQrCodes('${event.id}')"
                    class="w-full bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-lg transition text-xs">
                    Eliminar Todos QR Codes
                  </button>
                ` : ''}
              </div>
            ` : ''}
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Token do Evento
            </label>
            <div class="bg-gray-100 px-3 py-2 rounded-lg text-xs font-mono break-all">
              ${event.token}
            </div>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Link para Cliente
            </label>
            <div class="bg-gray-100 px-3 py-2 rounded-lg text-xs break-all mb-2">
              ${window.location.origin}${window.location.pathname}?token=${event.token}
            </div>
            <button 
              onclick="copyClientLink('${event.token}')"
              class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition text-xs">
              üìã Copiar Link
            </button>
          </div>
          
          <div>
            <label class="flex items-center">
              <input 
                type="checkbox" 
                ${event.active ? 'checked' : ''}
                onchange="toggleEventActive('${event.id}')"
                class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
              <span class="ml-2 text-sm font-medium text-gray-700">
                Evento Ativo
              </span>
            </label>
          </div>
          
          <button 
            onclick="confirmDeleteEvent('${event.id}')"
            class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm">
            Eliminar Evento
          </button>
        </div>
      `;
    }
    
    function renderEventMain(event) {
      const eventInvites = invites.filter(i => i.event_id === event.id);
      
      return `
        <div class="p-8">
          <div class="mb-8">
            <h3 class="text-2xl font-bold text-gray-800 mb-2">${event.event_name}</h3>
            <p class="text-gray-600">Posicione o texto ${event.qr_enabled ? 'e QR code ' : ''}arrastando sobre o PDF</p>
          </div>
          
          <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <div class="canvas-container inline-block relative">
              <canvas id="pdfCanvas"></canvas>
              <div 
                id="draggableText"
                class="draggable absolute"
                style="
                  font-size: ${event.font_size}px;
                  color: ${event.text_color};
                  font-weight: 600;
                  font-family: ${event.font_name || 'Arial'}, sans-serif;
                  pointer-events: auto;
                  white-space: nowrap;
                  z-index: 10;
                  cursor: move;
                  left: 100px;
                  top: 100px;
                ">
                Nome Exemplo
              </div>
              ${event.qr_enabled ? `
                <div 
                  id="draggableQr"
                  class="draggable absolute"
                  style="
                    border: 2px dashed #6366f1;
                    background: rgba(99, 102, 241, 0.1);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    pointer-events: auto;
                    z-index: 10;
                    cursor: move;
                    font-size: 12px;
                    color: #6366f1;
                    font-weight: 600;
                    text-align: center;
                    left: 100px;
                    top: 200px;
                    width: 100px;
                    height: 100px;
                  ">
                  QR CODE<br>${event.qr_size_pt}pt
                  <div class="resize-handle bottom-right" onmousedown="startResize(event)" ontouchstart="startResize(event)"></div>
                </div>
              ` : ''}
            </div>
          </div>
          
          <div class="bg-white rounded-xl shadow-lg p-6">
            <h4 class="text-xl font-bold text-gray-800 mb-4">
              Convites Gerados (${eventInvites.length}/${event.max_invites})
            </h4>
            
            <div id="invitesList" class="space-y-2">
              ${eventInvites.length === 0 ? `
                <p class="text-gray-500 text-center py-8">Nenhum convite gerado ainda</p>
              ` : eventInvites.map(invite => `
                <div class="flex items-center justify-between bg-gray-50 px-4 py-3 rounded-lg">
                  <span class="font-medium text-gray-800">${invite.guest_name}</span>
                  <div class="flex gap-2">
                    <button 
                      onclick="handleRedownload('${event.id}', '${invite.guest_name}')"
                      class="text-indigo-600 hover:text-indigo-800 text-sm">
                           Baixar
                    </button>
                    <button 
                      onclick="confirmDeleteInvite('${invite.id}', '${invite.guest_name}')"
                      class="text-red-600 hover:text-red-800 text-sm">
                      üóë Eliminar
                    </button>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
      `;
    }
    
    function renderClient() {
      const event = currentEvent;
      
      if (!event) {
        return `
          <div class="flex items-center justify-center min-h-full bg-gray-50 p-4">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-md w-full text-center">
              <div class="text-6xl mb-4">   Ô∏è</div>
              <h2 class="text-2xl font-bold text-gray-800 mb-4">Token Inv√°lido</h2>
              <p class="text-gray-600 mb-6">O token fornecido n√£o corresponde a nenhum evento.</p>
              <button 
                onclick="navigate('home')"
                class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                Voltar ao In√≠cio
              </button>
            </div>
          </div>
        `;
      }
      
      if (!event.active) {
        return `
          <div class="flex items-center justify-center min-h-full bg-gray-50 p-4">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-md w-full text-center">
              <div class="text-6xl mb-4">    </div>
              <h2 class="text-2xl font-bold text-gray-800 mb-4">Evento Inativo</h2>
              <p class="text-gray-600 mb-6">Este evento n√£o est√° mais aceitando convites.</p>
              <button 
                onclick="navigate('home')"
                class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                Voltar ao In√≠cio
              </button>
            </div>
          </div>
        `;
      }
      
      const eventInvites = invites.filter(i => i.event_id === event.id);
      
      // ‚úÖ CORRIGIDO: Contagem baseada APENAS no que foi configurado
      let effectiveLimit, remainingInvites, generatedCount;
      
      if (event.qr_enabled) {
        // ‚úÖ QR ATIVADO: Conta baseado em QR codes
        const qrStats = qrCodes.filter(qr => qr.event_id === event.id);
        const availableQrs = qrStats.filter(qr => !qr.used).length;
        const totalQrs = qrStats.length;
        
        effectiveLimit = totalQrs;
        remainingInvites = availableQrs;
        generatedCount = eventInvites.length;
      } else {
        // ‚úÖ QR DESATIVADO: Conta baseado em max_invites
        effectiveLimit = event.max_invites;
        generatedCount = eventInvites.length;
        remainingInvites = event.max_invites - generatedCount;
      }
      
      return `
        <div class="flex items-center justify-center min-h-full bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 p-4">
          <div class="bg-white rounded-2xl shadow-xl p-8 max-w-2xl w-full">
            <div class="text-center mb-8">
              <div class="text-6xl mb-4">üéâ</div>
              <h1 class="text-3xl font-bold text-gray-800 mb-2">${event.event_name}</h1>
              <p class="text-gray-600">Gere o seu convite personalizado</p>
              <p class="text-sm text-gray-500 mt-2">
                <span class="font-semibold text-green-600">${remainingInvites} dispon√≠ve${remainingInvites !== 1 ? 'is' : 'l'}</span>
                <span class="mx-2">‚Ä¢</span>
                <span class="font-semibold text-blue-600">${generatedCount} gerado${generatedCount !== 1 ? 's' : ''}</span>
              </p>
            </div>
            
            ${remainingInvites > 0 && remainingInvites <= 10 ? `
              <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-6">
                <div class="flex items-start justify-between gap-3">
                  <div class="flex-1">
                    <p class="text-xs text-blue-800">
                      üí° <strong>Restam ${remainingInvites} convite${remainingInvites !== 1 ? 's' : ''}</strong>. 
                      Pode adicionar +20 convites por apenas 15.000 Kz.
                    </p>
                  </div>
                  <button 
                    onclick="dismissUpgradeNotification()"
                    class="text-blue-600 hover:text-blue-800 text-xs font-medium">
                    ‚úï
                  </button>
                </div>
              </div>
            ` : ''}
            
            <form onsubmit="handleGenerateInvite(event)" class="space-y-4 mb-8" autocomplete="off">
              <div>
                <label for="guestName" class="block text-sm font-medium text-gray-700 mb-2">
                  Seu Nome Completo
                </label>
                <input 
                  type="text" 
                  id="guestName"
                  required
                  placeholder="Digite seu nome"
                  autocomplete="off"
                  autocorrect="off"
                  autocapitalize="off"
                  spellcheck="false"
                  class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
              </div>
              
              <button 
                type="submit"
                id="generateBtn"
                class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition">
                Gerar Convite
              </button>
            </form>
            
            ${eventInvites.length > 0 ? `
              <div class="border-t border-gray-200 pt-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                  Convites Gerados (${eventInvites.length})
                </h3>
                <div id="clientInvitesList" class="space-y-2 max-h-64 overflow-y-auto">
                  ${eventInvites.map(invite => `
                    <div class="flex items-center justify-between bg-gray-50 px-4 py-3 rounded-lg">
                      <span class="font-medium text-gray-800">${invite.guest_name}</span>
                      <button 
                        onclick="handleClientRedownload('${event.id}', '${invite.guest_name}')"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm transition">
                        ‚¨á Baixar
                      </button>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
            
            <button 
              onclick="navigate('home')"
              class="mt-6 w-full text-gray-600 hover:text-gray-800 text-sm">
              ‚Üê Voltar
            </button>
            
            <div class="mt-6 pt-4 border-t border-gray-200 text-center text-xs text-gray-500">
              ¬© AdKira 2026 Todos os direitos reservados
            </div>
          </div>
        </div>
      `;
    }
    
    // ============================================
    // HANDLERS
    // ============================================
    async function toggleMultipleTokens(eventId, enabled) {
      try {
        await updateEvent(eventId, { multiple_tokens: enabled });
        
        if (enabled) {
          //       Criar automaticamente 2 tokens quando ativar a op√ß√£o
          const existingTokens = await loadEventTokens(eventId);
          
          if (existingTokens.length === 0) {
            // Token 1
            await createEventToken(eventId, {
              token: generateSecureToken(),
              token_name: 'Token 1',
              max_invites: 20
            });
            
            // Token 2
            await createEventToken(eventId, {
              token: generateSecureToken(),
              token_name: 'Token 2',
              max_invites: 20
            });
            
            showToast('2 tokens criados automaticamente!');
          }
          
          await loadEventTokens(eventId);
        }
        
        render();
        
        setTimeout(async () => {
          if (currentEvent && currentEvent.pdf_path) {
            const pdfBlob = await downloadFile(currentEvent.pdf_path);
            if (pdfBlob) {
              const arrayBuffer = await pdfBlob.arrayBuffer();
              await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
              initDragAndDrop();
            }
          }
          
          if (enabled) {
            updateTokensList();
          }
        }, 100);
      } catch (error) {
        console.error('Erro ao alternar m√∫ltiplos tokens:', error);
        showToast('Erro ao alternar m√∫ltiplos tokens', 'error');
      }
    }
    
    async function showCreateTokenModal(eventId) {
      const tokenName = prompt('Nome do Token (ex: "Noivo 1", "Fam√≠lia"):');
      if (!tokenName || !tokenName.trim()) return;
      
      const maxInvites = prompt('Limite de convites para este token:', '20');
      if (!maxInvites || isNaN(parseInt(maxInvites))) return;
      
      const token = generateSecureToken();
      
      const newToken = await createEventToken(eventId, {
        token: token,
        token_name: tokenName.trim(),
        max_invites: parseInt(maxInvites)
      });
      
      if (newToken) {
        await loadEventTokens(eventId);
        updateTokensList();
      }
    }
    
    async function updateTokensList() {
      const tokensList = document.getElementById('tokensList');
      if (!tokensList || !currentEvent) return;
      
      if (eventTokens.length === 0) {
        tokensList.innerHTML = '<p class="text-xs text-gray-500 text-center py-2">Nenhum token criado</p>';
        return;
      }
      
      const tokensHtml = await Promise.all(eventTokens.map(async (token) => {
        const usedCount = await getTokenStats(token.id);
        const percentage = (usedCount / token.max_invites) * 100;
        
        return `
          <div class="bg-white p-3 rounded border ${token.active ? 'border-green-300' : 'border-gray-300'}">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center gap-2">
                <span class="font-bold text-sm">${token.token_name}</span>
                <span class="text-xs px-2 py-0.5 rounded ${token.active ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}">
                  ${token.active ? 'Ativo' : 'Inativo'}
                </span>
              </div>
              <button 
                onclick="toggleTokenActive('${token.id}', ${!token.active})"
                class="text-xs ${token.active ? 'text-orange-600 hover:text-orange-800' : 'text-green-600 hover:text-green-800'}">
                ${token.active ? '‚è∏ Pausar' : '‚ñ∂ Ativar'}
              </button>
            </div>
            
            <div class="mb-2">
              <div class="flex items-center justify-between text-xs text-gray-600 mb-1">
                <span>${usedCount} / ${token.max_invites} convites</span>
                <span>${Math.round(percentage)}%</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-2">
                <div class="bg-indigo-600 h-2 rounded-full" style="width: ${percentage}%"></div>
              </div>
            </div>
            
            <div class="flex items-center gap-2">
              <input 
                type="number" 
                value="${token.max_invites}"
                min="1"
                onchange="updateEventToken('${token.id}', { max_invites: parseInt(this.value) })"
                class="flex-1 px-2 py-1 border border-gray-300 rounded text-xs">
              <button 
                onclick="copyTokenLink('${token.token}')"
                class="bg-indigo-600 hover:bg-indigo-700 text-white px-2 py-1 rounded text-xs transition">
                üìã Copiar
              </button>
              <button 
                onclick="confirmDeleteToken('${token.id}')"
                class="text-red-600 hover:text-red-800 text-xs">
                üóë
              </button>
            </div>
          </div>
        `;
      }));
      
      tokensList.innerHTML = tokensHtml.join('');
    }
    
    async function toggleTokenActive(tokenId, active) {
      try {
        await updateEventToken(tokenId, { active });
        await loadEventTokens(selectedEventId);
        updateTokensList();
      } catch (error) {
        console.error('Erro ao alternar estado do token:', error);
      }
    }
    
    function copyTokenLink(token) {
      const link = `${window.location.origin}${window.location.pathname}?token=${token}`;
      
      navigator.clipboard.writeText(link).then(() => {
        showToast('Link copiado!');
      }).catch(err => {
        console.error('Erro ao copiar:', err);
        showToast('Erro ao copiar link', 'error');
      });
    }
    
    function confirmDeleteToken(tokenId) {
      if (confirm('Eliminar este token? Esta a√ß√£o n√£o pode ser desfeita.')) {
        handleDeleteToken(tokenId);
      }
    }
    
    async function handleDeleteToken(tokenId) {
      try {
        const success = await deleteEventToken(tokenId);
        if (success) {
          await loadEventTokens(selectedEventId);
          updateTokensList();
        }
      } catch (error) {
        console.error('Erro ao eliminar token:', error);
      }
    }
    
    async function handleTokenSubmit() {
      try {
        const input = document.getElementById('tokenInput');
        const token = input.value.trim();
        
        if (!token) {
          showToast('Insira um token v√°lido', 'error');
          return;
        }
        
        if (!validateToken(token)) {
          showToast('Token inv√°lido', 'error');
          return;
        }
        
        const result = await loadEventByTokenString(token);
        if (result) {
          navigate('client', { token });
        }
      } catch (error) {
        console.error('Erro ao verificar token:', error);
        showToast('Erro ao verificar token', 'error');
      }
    }
    
    async function handleLogin(e) {
      e.preventDefault();
      
      try {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        
        await login(email, password);
      } catch (error) {
        console.error('Erro ao fazer login:', error);
        showToast('Erro ao fazer login', 'error');
      }
    }
    
    async function handlePdfUpload(e) {
      try {
        const file = e.target.files[0];
        if (!file) return;
        
        if (file.size > 10 * 1024 * 1024) {
          showToast('PDF deve ter no m√°ximo 10MB', 'error');
          e.target.value = '';
          return;
        }
        
        const arrayBuffer = await file.arrayBuffer();
        tempPdfBytes = new Uint8Array(arrayBuffer);
      } catch (error) {
        console.error('Erro ao processar PDF:', error);
        showToast('Erro ao processar PDF', 'error');
      }
    }
    
    async function handleFontUpload(e) {
      try {
        const file = e.target.files[0];
        if (!file) return;
        
        const ext = file.name.split('.').pop().toLowerCase();
        if (!['ttf', 'otf'].includes(ext)) {
          showToast('Apenas fontes .ttf ou .otf', 'error');
          e.target.value = '';
          return;
        }
        
        const arrayBuffer = await file.arrayBuffer();
        tempFontBytes = new Uint8Array(arrayBuffer);
        tempFontName = file.name;
        
        if (selectedEventId) {
          const fontPath = await uploadFont(selectedEventId, tempFontBytes, tempFontName);
          if (fontPath) {
            await updateEvent(selectedEventId, {
              font_path: fontPath,
              font_name: tempFontName
            });
            showToast('Fonte atualizada');
          }
        }
      } catch (error) {
        console.error('Erro ao processar fonte:', error);
        showToast('Erro ao processar fonte', 'error');
      }
    }
    
    async function handlePdfReupload(e) {
      try {
        const file = e.target.files[0];
        if (!file) return;
        
        if (file.size > 10 * 1024 * 1024) {
          showToast('PDF deve ter no m√°ximo 10MB', 'error');
          e.target.value = '';
          return;
        }
        
        if (!selectedEventId) {
          showToast('Nenhum evento selecionado', 'error');
          e.target.value = '';
          return;
        }
        
        const arrayBuffer = await file.arrayBuffer();
        const pdfBytes = new Uint8Array(arrayBuffer);
        
        const pdfPath = await uploadPdf(selectedEventId, pdfBytes);
        if (pdfPath) {
          await updateEvent(selectedEventId, { 
            pdf_path: pdfPath,
            page_number: 1  // Reset para p√°gina 1 quando trocar o PDF
          });
          
          showToast('PDF atualizado com sucesso!');
          
          // Renderizar o novo PDF no canvas
          setTimeout(async () => {
            if (currentEvent && currentEvent.pdf_path) {
              const pdfBlob = await downloadFile(currentEvent.pdf_path);
              if (pdfBlob) {
                const arrayBuffer = await pdfBlob.arrayBuffer();
                await renderPdfOnCanvas(new Uint8Array(arrayBuffer), 1);
                initDragAndDrop();
              }
            }
          }, 100);
        }
        
        e.target.value = '';
      } catch (error) {
        console.error('Erro ao re-fazer upload do PDF:', error);
        showToast('Erro ao atualizar PDF', 'error');
        e.target.value = '';
      }
    }
    
    async function handleCreateEvent(e) {
      e.preventDefault();
      
      try {
        const eventName = document.getElementById('eventName').value;
        const eventToken = document.getElementById('eventToken').value;
        const maxInvites = parseInt(document.getElementById('maxInvites').value);
        
        if (!tempPdfBytes) {
          showToast('Fa√ßa upload do PDF', 'error');
          return;
        }
        
        if (!validateToken(eventToken)) {
          showToast('Token inv√°lido', 'error');
          return;
        }
        
        const eventId = crypto.randomUUID();
        
        const pdfPath = await uploadPdf(eventId, tempPdfBytes);
        if (!pdfPath) {
          showToast('Erro ao fazer upload', 'error');
          return;
        }
        
        let fontPath = '';
        if (tempFontBytes) {
          fontPath = await uploadFont(eventId, tempFontBytes, tempFontName);
        }
        
        const event = await createEvent({
          event_name: eventName,
          token: eventToken,
          pdf_path: pdfPath,
          font_path: fontPath,
          font_name: tempFontName || '',
          max_invites: maxInvites
        });
        
        if (event) {
          await loadEvents();
          navigate('admin');
        }
      } catch (error) {
        console.error('Erro ao criar evento:', error);
        showToast('Erro ao criar evento', 'error');
      }
    }
    
    async function handleQrCodesUpload(e) {
      try {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        
        if (!selectedEventId) {
          showToast('Nenhum evento selecionado', 'error');
          e.target.value = '';
          return;
        }
        
        const btn = window.event.target;
        btn.disabled = true;
        
        const success = await uploadQrCodes(selectedEventId, files);
        
        if (success) {
          await loadQrCodes(selectedEventId);
          render();
          
          setTimeout(async () => {
            if (currentEvent && currentEvent.pdf_path) {
              const pdfBlob = await downloadFile(currentEvent.pdf_path);
              if (pdfBlob) {
                const arrayBuffer = await pdfBlob.arrayBuffer();
                await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
                initDragAndDrop();
              }
            }
          }, 100);
        }
        
        e.target.value = '';
        btn.disabled = false;
      } catch (error) {
        console.error('Erro ao processar QR codes:', error);
        showToast('Erro ao processar QR codes', 'error');
        e.target.value = '';
      }
    }
    
    async function toggleQrEnabled(eventId, enabled) {
      try {
        await updateEvent(eventId, { qr_enabled: enabled });
      } catch (error) {
        console.error('Erro ao alternar QR codes:', error);
        showToast('Erro ao alternar QR codes', 'error');
      }
    }
    
    async function handleMaxInvitesChange(eventId, newLimit) {
      try {
        const event = await loadEvent(eventId);
        if (!event) {
          showToast('Evento n√£o encontrado', 'error');
          return;
        }
        
        // ‚úÖ SE QR codes estiverem ativados, avisar se o limite for maior que QR codes dispon√≠veis
        if (event.qr_enabled) {
          const qrs = await loadQrCodes(eventId);
          const availableQrs = qrs.filter(qr => !qr.used).length;
          
          if (newLimit > availableQrs) {
            showToast(`Aten√ß√£o: Limite definido para ${newLimit}, mas s√≥ existem ${availableQrs} QR code${availableQrs !== 1 ? 's' : ''} dispon√≠ve${availableQrs !== 1 ? 'is' : 'l'}. Carregue mais QR codes!`, 'error');
          }
        }
        
        await updateEvent(eventId, { max_invites: newLimit });
      } catch (error) {
        console.error('Erro ao atualizar limite:', error);
        showToast('Erro ao atualizar limite', 'error');
      }
    }
    
    function confirmDeleteAllQrCodes(eventId) {
      const confirmBtn = window.event.target;
      
      if (confirmBtn.textContent.includes('Eliminar Todos')) {
        confirmBtn.textContent = 'Confirmar Elimina√ß√£o?';
        confirmBtn.classList.remove('bg-orange-600', 'hover:bg-orange-700');
        confirmBtn.classList.add('bg-red-700', 'hover:bg-red-800');
        
        setTimeout(() => {
          confirmBtn.textContent = 'Eliminar Todos QR Codes';
          confirmBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
          confirmBtn.classList.add('bg-orange-600', 'hover:bg-orange-700');
        }, 3000);
      } else {
        handleDeleteAllQrCodes(eventId);
      }
    }
    
    async function handleDeleteAllQrCodes(eventId) {
      try {
        const success = await deleteAllQrCodes(eventId);
        
        if (success) {
          await loadQrCodes(eventId);
          render();
          
          setTimeout(async () => {
            if (currentEvent && currentEvent.pdf_path) {
              const pdfBlob = await downloadFile(currentEvent.pdf_path);
              if (pdfBlob) {
                const arrayBuffer = await pdfBlob.arrayBuffer();
                await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
                initDragAndDrop();
              }
            }
          }, 100);
        }
      } catch (error) {
        console.error('Erro ao eliminar QR codes:', error);
        showToast('Erro ao eliminar QR codes', 'error');
      }
    }
    
    async function handleEventSelect(eventId) {
      try {
        unsubscribeFromEvent();
        
        if (!eventId) {
          selectedEventId = null;
          currentEvent = null;
          render();
          return;
        }
        
        selectedEventId = eventId;
        currentEvent = await loadEvent(eventId);
        
        await loadInvites(eventId);
        await loadQrCodes(eventId);
        
        // ‚úÖ Carregar tokens se m√∫ltiplos tokens estiverem ativados
        if (currentEvent.multiple_tokens) {
          await loadEventTokens(eventId);
        }
        
        subscribeToEvent(eventId);
        
        render();
        
        setTimeout(async () => {
          if (currentEvent && currentEvent.pdf_path) {
            const pdfBlob = await downloadFile(currentEvent.pdf_path);
            if (pdfBlob) {
              const arrayBuffer = await pdfBlob.arrayBuffer();
              await renderPdfOnCanvas(new Uint8Array(arrayBuffer), currentEvent.page_number);
              initDragAndDrop();
            }
          }
        }, 100);
      } catch (error) {
        console.error('Erro ao selecionar evento:', error);
        showToast('Erro ao selecionar evento', 'error');
      }
    }
    
    async function handlePageChange(pageNumber) {
      try {
        await updateEvent(selectedEventId, { page_number: parseInt(pageNumber) });
        
        if (currentEvent && currentEvent.pdf_path) {
          const pdfBlob = await downloadFile(currentEvent.pdf_path);
          if (pdfBlob) {
            const arrayBuffer = await pdfBlob.arrayBuffer();
            await renderPdfOnCanvas(new Uint8Array(arrayBuffer), parseInt(pageNumber));
          }
        }
      } catch (error) {
        console.error('Erro ao mudar p√°gina:', error);
        showToast('Erro ao mudar p√°gina', 'error');
      }
    }
    
    async function handleGenerateInvite(e) {
      e.preventDefault();
      
      try {
        const guestName = document.getElementById('guestName').value.trim();
        const btn = document.getElementById('generateBtn');
        
        if (!guestName) {
          showToast('Insira seu nome', 'error');
          return;
        }
        
        btn.disabled = true;
        btn.textContent = 'Gerando...';
        
        // ‚úÖ Verificar se √© token principal ou token secund√°rio
        const result = await loadEventByTokenString(currentToken);
        if (!result) {
          showToast('Evento n√£o encontrado', 'error');
          btn.disabled = false;
          btn.textContent = 'Gerar Convite';
          return;
        }
        
        const event = result.event;
        const tokenData = result.tokenData; // null se for token principal
        
        currentEvent = event;
        
        // ‚úÖ Passar token_id para generateInvitePdf (se houver)
        const pdfBytes = await generateInvitePdf(event.id, guestName, tokenData ? tokenData.id : null);
        
        if (pdfBytes) {
          downloadPdf(pdfBytes, `${guestName}.pdf`);
          showToast('Convite gerado!');
          document.getElementById('guestName').value = '';
          
          // ‚úÖ Atualizar lista e estat√≠sticas localmente (sem esperar realtime)
          await loadInvites(event.id);
          await loadQrCodes(event.id);
          updateClientInvitesList();
          updateClientStats();
        }
        
        btn.disabled = false;
        btn.textContent = 'Gerar Convite';
      } catch (error) {
        console.error('Erro ao gerar convite:', error);
        showToast('Erro ao gerar convite', 'error');
        
        const btn = document.getElementById('generateBtn');
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Gerar Convite';
        }
      }
    }
    
    async function handleRedownload(eventId, guestName) {
      try {
        const btn = window.event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Gerando...';
        btn.disabled = true;
        
        const event = await loadEvent(eventId);
        if (!event) {
          showToast('Evento n√£o encontrado', 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const pdfBlob = await downloadFile(event.pdf_path);
        if (!pdfBlob) {
          showToast('Erro ao carregar PDF base', 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const pdfBytes = await pdfBlob.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        
        pdfDoc.registerFontkit(fontkit);
        
        let font;
        try {
          if (event.font_path) {
            const fontBlob = await downloadFile(event.font_path);
            if (fontBlob) {
              const fontBytes = await fontBlob.arrayBuffer();
              font = await pdfDoc.embedFont(fontBytes);
            } else {
              showToast('Fonte personalizada n√£o encontrada. A usar fonte padr√£o', 'error');
              font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
            }
          } else {
            font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
          }
        } catch (fontError) {
          console.error('Erro ao carregar fonte personalizada:', fontError);
          showToast('Erro ao carregar fonte personalizada. A usar fonte padr√£o', 'error');
          font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
        }
        
        let displayName = guestName;
        if (event.text_transform === 'uppercase') {
          displayName = displayName.toUpperCase();
        } else if (event.text_transform === 'lowercase') {
          displayName = displayName.toLowerCase();
        } else if (event.text_transform === 'capitalize') {
          displayName = displayName.split(' ').map(w => 
            w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
          ).join(' ');
        }
        
        const pages = pdfDoc.getPages();
        
        if (event.page_number < 1 || event.page_number > pages.length) {
          showToast(`P√°gina ${event.page_number} n√£o existe. O PDF tem ${pages.length} p√°gina${pages.length !== 1 ? 's' : ''}.`, 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const page = pages[event.page_number - 1];
        
        const textWidth = font.widthOfTextAtSize(displayName, event.font_size);
        
        let finalX = event.position_x_pt;
        
        if (event.anchor_position === 'center') {
          finalX = event.position_x_pt - (textWidth / 2);
        } else if (event.anchor_position === 'right') {
          finalX = event.position_x_pt - textWidth;
        }
        
        const textHeight = event.font_size;
        
        const r = parseInt(event.text_color.slice(1, 3), 16) / 255;
        const g = parseInt(event.text_color.slice(3, 5), 16) / 255;
        const b = parseInt(event.text_color.slice(5, 7), 16) / 255;
        
        page.drawText(displayName, {
          x: finalX,
          y: event.position_y_pt - textHeight,
          size: event.font_size,
          font: font,
          color: PDFLib.rgb(r, g, b)
        });
        
        const modifiedPdfBytes = await pdfDoc.save();
        
        downloadPdf(modifiedPdfBytes, `${guestName}.pdf`);
        showToast('Convite baixado novamente!');
        
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (error) {
        console.error('Erro ao re-baixar:', error);
        showToast('Erro ao re-baixar convite: ' + error.message, 'error');
        
        const btn = window.event.target;
        btn.textContent = '‚¨á Baixar';
        btn.disabled = false;
      }
    }
    
    async function handleClientRedownload(eventId, guestName) {
      try {
        const btn = window.event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Gerando...';
        btn.disabled = true;
        
        // ‚úÖ Apenas re-gera o PDF - N√ÉO cria novo convite
        const event = await loadEvent(eventId);
        if (!event) {
          showToast('Evento n√£o encontrado', 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const pdfBlob = await downloadFile(event.pdf_path);
        if (!pdfBlob) {
          showToast('Erro ao carregar PDF base', 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const pdfBytes = await pdfBlob.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        
        pdfDoc.registerFontkit(fontkit);
        
        let font;
        try {
          if (event.font_path) {
            const fontBlob = await downloadFile(event.font_path);
            if (fontBlob) {
              const fontBytes = await fontBlob.arrayBuffer();
              font = await pdfDoc.embedFont(fontBytes);
            } else {
              font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
            }
          } else {
            font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
          }
        } catch (fontError) {
          console.error('Erro ao carregar fonte personalizada:', fontError);
          font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
        }
        
        let displayName = guestName;
        if (event.text_transform === 'uppercase') {
          displayName = displayName.toUpperCase();
        } else if (event.text_transform === 'lowercase') {
          displayName = displayName.toLowerCase();
        } else if (event.text_transform === 'capitalize') {
          displayName = displayName.split(' ').map(w => 
            w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
          ).join(' ');
        }
        
        const pages = pdfDoc.getPages();
        
        if (event.page_number < 1 || event.page_number > pages.length) {
          showToast(`Erro: p√°gina ${event.page_number} n√£o existe`, 'error');
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
        
        const page = pages[event.page_number - 1];
        
        const textWidth = font.widthOfTextAtSize(displayName, event.font_size);
        
        let finalX = event.position_x_pt;
        
        if (event.anchor_position === 'center') {
          finalX = event.position_x_pt - (textWidth / 2);
        } else if (event.anchor_position === 'right') {
          finalX = event.position_x_pt - textWidth;
        }
        
        const textHeight = event.font_size;
        
        const r = parseInt(event.text_color.slice(1, 3), 16) / 255;
        const g = parseInt(event.text_color.slice(3, 5), 16) / 255;
        const b = parseInt(event.text_color.slice(5, 7), 16) / 255;
        
        page.drawText(displayName, {
          x: finalX,
          y: event.position_y_pt - textHeight,
          size: event.font_size,
          font: font,
          color: PDFLib.rgb(r, g, b)
        });
        
        const modifiedPdfBytes = await pdfDoc.save();
        
        downloadPdf(modifiedPdfBytes, `${guestName}.pdf`);
        showToast('Convite baixado!');
        
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (error) {
        console.error('Erro ao baixar:', error);
        showToast('Erro ao baixar convite', 'error');
        
        const btn = window.event.target;
        btn.textContent = '‚¨á Baixar';
        btn.disabled = false;
      }
    }
    
    function confirmDeleteInvite(inviteId, guestName) {
      const confirmBtn = window.event.target;
      
      if (confirmBtn.textContent.includes('Eliminar')) {
        confirmBtn.textContent = 'Confirmar?';
        confirmBtn.classList.remove('text-red-600', 'hover:text-red-800');
        confirmBtn.classList.add('text-red-800', 'font-bold');
        
        setTimeout(() => {
          confirmBtn.textContent = 'üóë Eliminar';
          confirmBtn.classList.remove('text-red-800', 'font-bold');
          confirmBtn.classList.add('text-red-600', 'hover:text-red-800');
        }, 3000);
      } else {
        handleDeleteInvite(inviteId);
      }
    }
    
    async function handleDeleteInvite(inviteId) {
      try {
        await deleteInvite(inviteId);
      } catch (error) {
        console.error('Erro:', error);
        showToast('Erro ao eliminar', 'error');
      }
    }
    
    function confirmDeleteEvent(eventId) {
      const confirmBtn = window.event.target;
      
      if (confirmBtn.textContent === 'Eliminar Evento') {
        confirmBtn.textContent = 'Confirmar?';
        confirmBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        confirmBtn.classList.add('bg-red-800', 'hover:bg-red-900');
        
        setTimeout(() => {
          confirmBtn.textContent = 'Eliminar Evento';
          confirmBtn.classList.remove('bg-red-800', 'hover:bg-red-900');
          confirmBtn.classList.add('bg-red-600', 'hover:bg-red-700');
        }, 3000);
      } else {
        deleteEvent(eventId);
      }
    }
    
    function copyClientLink(token) {
      const link = `${window.location.origin}${window.location.pathname}?token=${token}`;
      
      navigator.clipboard.writeText(link).then(() => {
        showToast('Link copiado para √°rea de transfer√™ncia!');
      }).catch(err => {
        console.error('Erro ao copiar:', err);
        showToast('Erro ao copiar link', 'error');
      });
    }
    
    function dismissUpgradeNotification() {
      const notification = window.event.target.closest('div.bg-gradient-to-r');
      if (notification) {
        notification.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => {
          notification.remove();
        }, 300);
      }
    }
    
    function updateInvitesList() {
      const invitesList = document.getElementById('invitesList');
      if (!invitesList || !currentEvent) return;
      
      const eventInvites = invites.filter(i => i.event_id === currentEvent.id);
      
      if (eventInvites.length === 0) {
        invitesList.innerHTML = '<p class="text-gray-500 text-center py-8">Nenhum convite gerado ainda</p>';
      } else {
        invitesList.innerHTML = eventInvites.map(invite => `
          <div class="flex items-center justify-between bg-gray-50 px-4 py-3 rounded-lg">
            <span class="font-medium text-gray-800">${invite.guest_name}</span>
            <div class="flex gap-2">
              <button 
                onclick="handleRedownload('${currentEvent.id}', '${invite.guest_name}')"
                class="text-indigo-600 hover:text-indigo-800 text-sm">
                ‚¨á Baixar
              </button>
              <button 
                onclick="confirmDeleteInvite('${invite.id}', '${invite.guest_name}')"
                class="text-red-600 hover:text-red-800 text-sm">
                üóë Eliminar
              </button>
            </div>
          </div>
        `).join('');
      }
    }
    
    function updateClientInvitesList() {
      const clientInvitesList = document.getElementById('clientInvitesList');
      if (!clientInvitesList || !currentEvent) return;
      
      const eventInvites = invites.filter(i => i.event_id === currentEvent.id);
      
      if (eventInvites.length === 0) {
        // Se n√£o h√° convites, esconde a se√ß√£o
        const section = clientInvitesList.parentElement;
        if (section) {
          section.style.display = 'none';
        }
      } else {
        const section = clientInvitesList.parentElement;
        if (section) {
          section.style.display = 'block';
        }
        
        clientInvitesList.innerHTML = eventInvites.map(invite => `
          <div class="flex items-center justify-between bg-gray-50 px-4 py-3 rounded-lg">
            <span class="font-medium text-gray-800">${invite.guest_name}</span>
            <button 
              onclick="handleClientRedownload('${currentEvent.id}', '${invite.guest_name}')"
              class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm transition">
              ‚¨á Baixar
            </button>
          </div>
        `).join('');
      }
    }
    
    // ‚úÖ NOVA FUN√á√ÉO: Atualizar estat√≠sticas em tempo real
    function updateClientStats() {
      const statsElement = document.querySelector('p.text-sm.text-gray-500.mt-2');
      if (!statsElement || !currentEvent) return;
      
      const eventInvites = invites.filter(i => i.event_id === currentEvent.id);
      
      let effectiveLimit, remainingInvites, generatedCount;
      
      if (currentEvent.qr_enabled) {
        const qrStats = qrCodes.filter(qr => qr.event_id === currentEvent.id);
        const availableQrs = qrStats.filter(qr => !qr.used).length;
        const totalQrs = qrStats.length;
        
        effectiveLimit = totalQrs;
        remainingInvites = availableQrs;
        generatedCount = eventInvites.length;
      } else {
        effectiveLimit = currentEvent.max_invites;
        generatedCount = eventInvites.length;
        remainingInvites = currentEvent.max_invites - generatedCount;
      }
      
      statsElement.innerHTML = `
        <span class="font-semibold text-green-600">${remainingInvites} dispon√≠ve${remainingInvites !== 1 ? 'is' : 'l'}</span>
        <span class="mx-2">‚Ä¢</span>
        <span class="font-semibold text-blue-600">${generatedCount} gerado${generatedCount !== 1 ? 's' : ''}</span>
      `;
    }
    
    // ============================================
    // RENDER
    // ============================================
    function render() {
      const app = document.getElementById('app');
      
      let html = '';
      
      switch (currentView) {
        case 'home':
          html = renderHome();
          break;
        case 'login':
          html = renderLogin();
          break;
        case 'admin':
          html = renderAdmin();
          break;
        case 'admin-create':
          html = renderAdminCreate();
          break;
        case 'client':
          html = renderClient();
          break;
        default:
          html = renderHome();
      }
      
      app.innerHTML = html;
    }
    
    // ============================================
    // INIT
    // ============================================
    async function init() {
      try {
        setupAuthListener();
        
        await waitForAuthReady();
        
        const urlParams = new URLSearchParams(window.location.search);
        const urlToken = urlParams.get('token');
        
        if (urlToken) {
          if (validateToken(urlToken)) {
            currentToken = urlToken;
            const result = await loadEventByTokenString(urlToken);
            if (result) {
              currentEvent = result.event;
              await loadInvites(result.event.id);
              await loadQrCodes(result.event.id);
              
              // ‚úÖ Carregar tokens se m√∫ltiplos tokens estiverem ativados
              if (result.event.multiple_tokens) {
                await loadEventTokens(result.event.id);
              }
              
              subscribeToEvent(result.event.id);
              navigate('client', { token: urlToken });
            } else {
              navigate('home');
            }
          } else {
            showToast('Token inv√°lido', 'error');
            navigate('home');
          }
        } else if (isAdminAuthenticated) {
          await loadEvents();
          navigate('admin');
        } else {
          navigate('home');
        }
      } catch (error) {
        console.error('Erro:', error);
        showToast('Erro ao inicializar', 'error');
        navigate('home');
      }
    }
    
    init();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c715df054f106e3',t:'MTc2OTk0ODA1MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>